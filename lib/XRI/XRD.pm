package XRI::XRD;

use strict;
use warnings;
use Class::Field qw(field);
use Error qw(:try);
use XRI::SEP;
use XRI::Util qw(sort_by_priority parse_priority_node xpath);

field 'dom';

sub new {
    my ( $class, %args ) = @_;
    throw XRI::Exception::XRD(
        "No dom parameter to $class\::new()"
    ) unless defined $args{dom};
    my $self = bless( \%args, $class );
    $self->dom($args{dom});
    return $self;
}

sub canonical_id {
    my $self = shift;
    return &xpath('xrd:CanonicalID|xrds:CanonicalID', $self->dom)->to_literal;
}

sub local_ids {
    my $self = shift;
    return [ map { &parse_priority_node($_) }
	         &xpath('xrd:LocalID|xrds:LocalID', $self->dom) ];
}

sub local_ids_by_priority {
    my $self = shift;
    return map { $_->{value} } &sort_by_priority($self->local_ids);
}

# FIXME: Need to store the default list of SEPs, possibly as an attribute.
sub services {
    my $self = shift;
    return [ map { XRI::SEP->new(dom => $_) }
	         &xpath('xrd:Service', $self->dom) ];
}

sub services_by_priority {
    my $self = shift;
    return &sort_by_priority($self->services);
}

# %service_match = ( path => '', type => '', media_type => '' )

sub service_endpoints {
    my ($self, %service_match) = @_;
    my @all_services =  $self->services_by_priority;
    my @wanted_services = grep { $_->type->{value} eq $service_match{type} }
                               @all_services;
    my @uris = map { $_->{value} } map { @{$_->{uri}} } @wanted_services;
    return \@uris;
}


package XRI::Exception::XRD;
use base qw(Error::Simple);

1;

__END__

=head1 NAME

XRI::XRD -- Parses and represents XRD (XRI Descriptor) data

=head1 VERSION

Version 2.0.0

=head1 SYNOPSIS

Parses and represents XRI descriptors.  These will almost always be
generated by XRI::XRDS; users of this library should not need to use
its constructor.

    use XRI::XRD;

    my $xrd = XRI->resolve( '=eekim' );
    my $canonical_id = $xrd->canonical_id;
    my @local_ids   = $xrd->local_ids_by_priority;
    my @services    = $xrd->services_by_priority;

=head1 METHODS

=head2 new( dom => $xml_dom )

Constructor.  Given a DOM representing an XRD tree, populates the
appropriate data fields.

=head2 canonical_id ( )

Returns the XRI's CanonicalID.

=head2 local_ids ( )

Returns the XRI's LocalIDs in the order listed in the XRD.  We should
probably make this and services() private methods, as you should
almost always use local_ids_by_priority() instead.

Returns a list reference of hash references:

    [ { value => $value, priority => $priority }, ... ]

=head2 local_ids_by_priority( )

Returns a list of LocalIDs in order of priority.  This will not
necessarily return the same list each time it's called, because items
of equal priority are randomly sorted.

=head2 services( )

Returns the XRI's Services in the order listed in the XRD.  We should
probably make this a private method, as you should almomst always use
either services_by_priority() or service_endpoints().

Returns a list reference of hash references:

    [ { type => $type,
        priority => $priority,
        uri => [ { value => $value, priority => $priority }, ... ]
      }, ... ]

=head2 services_by_priority( )

Returns a list of Service hash references in order of priority.  This
will not necessarily return the same list each time it's called,
because items of equal priority are randomly sorted.

=head2 service_endpoints ( $service_type )

Returns a list reference of URIs corresponding to the service of
$service_type:

    [ $uri, $uri, ... ]

=head1 ACCESSORS / MUTATORS

These are essentially private methods, although they may be useful for
debugging.

=head2 dom( )

Returns the DOM representation of the XRD data that instantiated this
class.

=head1 NOTES

We aren't parsing and representing all fields in an XRD yet.  We chose
to focus on the fields we need for resolution (with the exception of
Ref and Redirect).

The services hash is a good candidate for being refactored into its
own class.

=head1 AUTHORS

Eugene Eric Kim, E<lt>eekim@blueoxen.comE<gt>

Matthew O'Connor, E<lt>matthew@canonical.orgE<gt>

=head1 COPYRIGHT & LICENSE

(C) Copyright 2008 Blue Oxen Associates.  All rights reserved.

This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

=cut
