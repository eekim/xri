package XRI::XRD;

use strict;
use warnings;
use Class::Field qw(field);
use Error qw(:try);
use XML::LibXML;

field 'dom';

sub new {
    my ( $class, %args ) = @_;
    throw XRI::Exception::XRD(
        "No dom parameter to $class\::new()"
    ) unless defined $args{dom};
    $args{services_by_path} = [];
    $args{services_by_type} = [];
    $args{services_by_mediatype} = [];
    my $self = bless( \%args, $class );
    $self->dom($args{dom});
    return $self;
}

sub canonical_id {
    my $self = shift;
    return $self->_xpath('xrd:CanonicalID|xrds:CanonicalID', $self->dom)->to_literal;
}

sub local_ids {
    my $self = shift;
    return [ map { _parse_priority_node($_) } $self->_xpath('xrd:LocalID|xrds:LocalID', $self->dom) ];
}

sub local_ids_by_priority {
    my $self = shift;
    return map { $_->{value} } _sort_by_priority($self->local_ids);
}

sub services {
    my $self = shift;
    return [ map { $self->_parse_services($_) } $self->_xpath('xrd:Service', $self->dom) ];
}

sub _parse_services {
    my ($self, $s_dom) = @_;
    my $s_hash = {};

    # FIXME: We're only parsing for Type, URI, and openid:Delegate.
    # There are a bunch of other possible elements that we're ignoring
    # because they're not important for our immediate needs. We're also
    # ignoring some attributes.

    my $priority = $s_dom->findvalue('./@priority');
    $s_hash->{priority} = $priority unless $priority eq '';

    my ($t_dom) = $self->_xpath('xrd:Type', $s_dom);
    $s_hash->{type} = $t_dom->to_literal if $t_dom;

    # FIXME: We're hard-coding a search for openid:Delegate, because
    # we know it's a commonly used SEP extension.  However, what we
    # should actually be returning is a list of all elements that don't
    # fall in the xrd namespace.
    my ($od_dom) = $self->_xpath('openid:Delegate', $s_dom);
    $s_hash->{openid_delegate} = $od_dom->to_literal if $od_dom;

    my @u_doms = $self->_xpath('xrd:URI', $s_dom);
    if (@u_doms) {
        $s_hash->{uri} = [ map { _parse_priority_node($_) } @u_doms ];
        $s_hash->{uri} = [ _sort_by_priority($s_hash->{uri}) ];
    }

    return $s_hash;
}

sub services_by_priority {
    my $self = shift;
    return _sort_by_priority($self->services);
}

# %service_match = ( path => '', type => '', media_type => '' )

sub service_endpoints {
    my ($self, %service_match) = @_;
    my @all_services =  $self->services_by_priority;
    my @wanted_services = grep { $_->{type} eq $service_match{type} }
                               @all_services;
    my @uris = map { $_->{value} } map { @{$_->{uri}} } @wanted_services;
    return \@uris;
}

sub _sort_by_priority {
    my $unsorted_list_ref = shift;
    my $p_hash;  # keys are priorities

    foreach my $item (@$unsorted_list_ref) {
        push @{$p_hash->{$item->{priority} || 0}}, $item;
    }
    return map _random_sort($p_hash->{$_}), sort { $a <=> $b } keys %$p_hash;
}

sub _random_sort {
    my $list_ref = shift;
    my @rand_sorted;
    while (@$list_ref) {
        my $i = int(rand(scalar(@$list_ref)));
        push @rand_sorted, splice @$list_ref, $i, 1;
    }
    return @rand_sorted;
}

sub _parse_priority_node {
    my $node_dom = shift;
    my $node_hash = {};

    my $priority = $node_dom->findvalue('./@priority');
    $node_hash->{priority} = $priority unless $priority eq '';
    $node_hash->{value} = $node_dom->to_literal;
    return $node_hash;
}

sub _xpath {
    my ( $self, $xpath, $node ) = @_;
    my $xpc = XML::LibXML::XPathContext->new;
    $xpc->registerNs( 'xrd',  'xri://$xrd*($v*2.0)' );
    $xpc->registerNs( 'xrds', 'xri://$xrds' );
    $xpc->registerNs( 'openid', 'http://openid.net/xmlns/1.0' );
    return $xpc->findnodes( $xpath, $node );
}


package XRI::Exception::XRD;
use base qw(Error::Simple);

1;

__END__

=head1 NAME

XRI::XRD -- Parses and represents XRD (XRI Descriptor) data

=head1 VERSION

Version 2.0.0

=head1 SYNOPSIS

Parses and represents XRI descriptors.  These will almost always be
generated by XRI::XRDS; users of this library should not need to use
its constructor.

    use XRI::XRD;

    my $xrd = XRI->resolve( '=eekim' );
    my $canonical_id = $xrd->canonical_id;
    my @local_ids   = $xrd->local_ids_by_priority;
    my @services    = $xrd->services_by_priority;

=head1 METHODS

=head2 new( dom => $xml_dom )

Constructor.  Given a DOM representing an XRD tree, populates the
appropriate data fields.

=head2 canonical_id ( )

Returns the XRI's CanonicalID.

=head2 local_ids ( )

Returns the XRI's LocalIDs in the order listed in the XRD.  We should
probably make this and services() private methods, as you should
almost always use local_ids_by_priority() instead.

Returns a list reference of hash references:

    [ { value => $value, priority => $priority }, ... ]

=head2 local_ids_by_priority( )

Returns a list of LocalIDs in order of priority.  This will not
necessarily return the same list each time it's called, because items
of equal priority are randomly sorted.

=head2 services( )

Returns the XRI's Services in the order listed in the XRD.  We should
probably make this a private method, as you should almomst always use
either services_by_priority() or service_endpoints().

Returns a list reference of hash references:

    [ { type => $type,
        priority => $priority,
        uri => [ { value => $value, priority => $priority }, ... ]
      }, ... ]

=head2 services_by_priority( )

Returns a list of Service hash references in order of priority.  This
will not necessarily return the same list each time it's called,
because items of equal priority are randomly sorted.

=head2 service_endpoints ( $service_type )

Returns a list reference of URIs corresponding to the service of
$service_type:

    [ $uri, $uri, ... ]

=head1 ACCESSORS / MUTATORS

These are essentially private methods, although they may be useful for
debugging.

=head2 dom( )

Returns the DOM representation of the XRD data that instantiated this
class.

=head1 NOTES

We aren't parsing and representing all fields in an XRD yet.  We chose
to focus on the fields we need for resolution (with the exception of
Ref and Redirect).

The services hash is a good candidate for being refactored into its
own class.

=head1 AUTHORS

Eugene Eric Kim, E<lt>eekim@blueoxen.comE<gt>

Matthew O'Connor, E<lt>matthew@canonical.orgE<gt>

=head1 COPYRIGHT & LICENSE

(C) Copyright 2008 Blue Oxen Associates.  All rights reserved.

This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

=cut
